\\
\linebreak
\smalltitle{سوال 5}\\
\smalltitle{الف)}\\
\emph{PC}:
در واقع برای
\emph{PC}
12
بیت کافی است. چرا که
$2^{12}=\frac{32768}{8}$
است و می‌توان کل مموری را آدرس دهی کرد. ولی از آنجا که طول هر کلمه 16 است، باید برای
\emph{PC}
16
بیت در نظر بگیریم.

\noindent
\emph{IR}:
از آنجا که طول دستورات ما 16 بیت هست، برای این رجیستر به 16 بیت نیاز داریم.

\noindent
\emph{SP}:
دقیقا مانند
\emph{PC}
می‌توان نتیجه گرفت که به 16 بیت نیاز داریم.

\smalltitle{ب)}\\
به نظر من این ماشین حساب بیشتر
\lr{RISC}
است. چرا که همه‌ی دستورالعمل‌های ما طول ثابت 16 بیت دارند و اینکه دستورالعمل‌های ما ساده هستند.
اما دقت کنید که تمامی دستورالعمل‌های ما با رجیستر سر و کار ندارند!
به عنوان مثال دستورات 
\codeword{add}, \codeword{sub}
و غیره با استک سر و کار دارند به جای رجیستر.
برای همین از این لحاظ شبیه
\lr{CISC}
هست. ولی در کل به نظر من این ماشین حساب
\lr{RISC}
است تا
\lr{CISC}.

\smalltitle{ج)}\\
در اول از همه دقت کنید که از آنجا که
push
در استک از آخر به اول هست و ماشین‌حساب نیز
\lr{big endian}
است، پس در صورتی که دو عدد 1 و 2 را به ترتیب در استک پوش کنیم، مثل این است که عدد
\lr{0x0201}
را در استک پوش کرده‌ایم. چرا که درصورتی که بخواهیم از استک
pop
کنیم ابتدا به 2 می‌رسیم و سپس 1 که نشان می‌دهد که 2 در بیت‌های پر ارزش است و 1 کم ارزش تر است.

\noindent
حال کد را تحلیل می‌کنیم.
در دو خط اول
\lr{0x000A}
را در استک پوش می‌کنیم.
سپس آدرس دستور جلوی 
\lr{loop label}
را در رجیستر
R4
قرار می‌دهیم.
دقت کنید که اگر آدرس بیشتر از 8 بیت باشد عدد اشتباهی در رجیستر می‌رود و برنامه خراب می‌شود.
سپس در
loop
می‌رویم و
\lr{0x0001}
و
\lr{0x0002}
را در استک پوش می‌کنیم.
سپس این دو عدد را با هم جمع میزنیم و آنرا در 
\lr{R1}
قرار می‌دهیم.

\noindent
در ادامه چندین
\lr{self modifying code}
اتفاق می‌افتد.
بدین صورت که در ابتدا عدد دستور اولین
\lr{pushi 0}
بعد از 
loop
را در
\lr{R2}
می‌ریزیم.
سپس مقدار
\lr{R1}
که جمع دو عدد داده شده در این دستور بود را در عدد
همان دستور ذخیره می‌کنیم.
در ادامه مقدار اولیه‌ی دستور
\lr{pushi 0}
را در
\lr{pushi 1}
ذخیره می‌کنیم.

\noindent
سپس عدد یک را در استک پوش می‌کنیم و عبارت
$10-1$
را حساب می‌کنیم و درصورتی که برابر 0 بود حلقه را تمام می‌کنیم. در غیر این صورت عدد حاصل را در استک
پوش می‌کنیم و حلقه را دوباره اجرا می‌کنیم.
منظور این پاراگراف این بود که حلقه را 10 بار اجرا می‌کنیم.

\noindent
در نهایت سعی می‌کنیم رابطه‌ای برای هر کدام از متغیر‌ها در بیاوریم.
فرض می‌کنیم که عدد دستور
\lr{pushi 1}
در مرحله‌ی 
$i$ام
برابر
$a_i$
است و عدد دستور
\lr{pushi 0}
بعدی در مرحله‌‌ی
$i$ام
برابر
$b_i$
است.
پس داریم:
\LTR
\begin{gather*}
a_0 = 1\\
b_0 = 0\\
a_{i+1} = b_i\\
b_{i+1} = (b_i + a_i \times 256 + 2) \% 256 = (b_i + 2) \% 256
\end{gather*}
\RTL

\smalltitle{د)}\\
\codesample{codes/5.asm}